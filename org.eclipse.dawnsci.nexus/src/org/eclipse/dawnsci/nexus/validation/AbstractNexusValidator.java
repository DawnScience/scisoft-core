/*-
 *******************************************************************************
 * Copyright (c) 2011, 2016 Diamond Light Source Ltd.
 * All rights reserved. This program and the accompanying materials
 * are made available under the terms of the Eclipse Public License v1.0
 * which accompanies this distribution, and is available at
 * http://www.eclipse.org/legal/epl-v10.html
 *
 * Contributors:
 *    Matthew Gerring - initial API and implementation and/or initial documentation
 *******************************************************************************/
package org.eclipse.dawnsci.nexus.validation;

import java.text.MessageFormat;
import java.util.Arrays;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Map;
import java.util.Set;

import javax.measure.Unit;
import javax.measure.format.ParserException;

import org.eclipse.dawnsci.analysis.api.tree.Attribute;
import org.eclipse.dawnsci.analysis.api.tree.DataNode;
import org.eclipse.dawnsci.analysis.api.tree.GroupNode;
import org.eclipse.dawnsci.analysis.api.tree.Node;
import org.eclipse.dawnsci.nexus.NXobject;
import org.eclipse.dawnsci.nexus.NXsubentry;
import org.eclipse.dawnsci.nexus.NXtransformations;
import org.eclipse.dawnsci.nexus.NexusApplicationDefinition;
import org.eclipse.dawnsci.nexus.NexusBaseClass;
import org.eclipse.dawnsci.nexus.NexusException;
import org.eclipse.dawnsci.nexus.NexusFile;
import org.eclipse.dawnsci.nexus.validation.ValidationReportEntry.Level;
import org.eclipse.dawnsci.nexus.validation.ValidationReportEntry.NodeType;
import org.eclipse.january.DatasetException;
import org.eclipse.january.dataset.Dataset;
import org.eclipse.january.dataset.IDataset;
import org.eclipse.january.dataset.ILazyDataset;

import si.uom.NonSI;
import si.uom.SI;
import tec.units.indriya.format.SimpleUnitFormat;

/**
 * Abstract superclass for Nexus application definition validators.
 * The logic for validating that nodes are not null, that fields and attributes
 * have the correct type etc. are in this abstract superclass.
 * A subclass exists for each application definition, generated by XSLT. Each subclass
 * invokes the methods in this abstract superclass as appropriate according to the
 * application definition as defined by the appropriate NXDL file.
 * <p>
 * Validators should not be reused.
 */
public abstract class AbstractNexusValidator implements NexusApplicationValidator {
	
	private static final class NexusPathSegment {
		private final String name;
		private final NexusBaseClass nexusBaseClass;
		
		NexusPathSegment(String name, NexusBaseClass nexusBaseClass) {
			this.name = name;
			this.nexusBaseClass = nexusBaseClass;
		}
		
		public String getName() {
			return name;
		}
		
		public NexusBaseClass getNexusBaseClass() {
			return nexusBaseClass;
		}
		
	}
	
	static {
		// ensure units classes are loaded and initialized, required for SimpleUnitFormat to parse their units strings
		SI.getInstance();
		NonSI.getInstance();
	}
	
	public static final String ATTRIBUTE_NAME_UNITS = "units";
	
	private final NexusApplicationDefinition applicationDefinition; 

	protected final ValidationReport validationReport = new ValidationReport();
	
	private NXsubentry entry = null;
	
	private Map<String, Integer> globalDimensionPlaceholderValues = new HashMap<>();
	
	private Map<String, Integer> localGroupDimensionPlaceholderValues = new HashMap<>();
	
	public AbstractNexusValidator(NexusApplicationDefinition appDef) {
		this.applicationDefinition = appDef;
	}
	
	public void setEntry(NXsubentry entry) {
		this.entry = entry;
	}
	
	public NexusApplicationDefinition getApplicationDefinition() {
		return applicationDefinition;
	}
	
	public ValidationReport getValidationReport() {
		return validationReport;
	}
	
	public void checkError() throws NexusException {
		if (validationReport.isError()) {
			final String validationSummary = validationReport.summarize(Level.ERROR);
			throw new NexusException("The nexus file is invalid according to application definition " +
					applicationDefinition + "\n" + validationSummary);
		}
	}

	/**
	 * Throw an {@link NexusValidationException} with the given message.
	 * @param message message
	 */
	public void addValidationEntry(Level level, NodeType nodeType, String nodeName, final String message) {
		validationReport.addValidationEntry(new ValidationReportEntry(level, nodeType, nodeName, message));
	}
	
	public boolean validate(boolean condition, Level level, NodeType nodeType, String nodeName, String message) {
		if (!condition) {
			addValidationEntry(level, nodeType, nodeName, message);
		}
		return condition;
	}
	
	/**
	 * Validates that the given group is not null.
	 * @param groupName name of group
	 * @param type type of group
	 * @param groupNode group node
	 */
	public boolean validateGroupNotNull(String groupName, Class<? extends NXobject> type, GroupNode groupNode) {
		return validate(groupNode != null, Level.ERROR, NodeType.GROUP_NODE, groupName, " The group was null");
	}
	
	/**
	 * Validate the number of occurrences of an unnamed group.
	 * @param <N>
	 * @param nxClass
	 * @param parentGroup
	 * @param optional
	 * @param multiple
	 */
	public boolean validateUnnamedGroupOccurrences(NXobject parentGroup, Class<? extends NXobject> nxClass, boolean optional, boolean multiple) {
		final Map<String, ?> childrenOfClass = parentGroup.getChildren(nxClass);
		
		if (!optional && childrenOfClass.isEmpty()) {
			addValidationEntry(Level.ERROR, NodeType.GROUP_NODE, null, (multiple ? "At least one" : "The unnamed") + " group of type " + nxClass.getSimpleName() + " must be present");
			return false;
		}
		if (!multiple && childrenOfClass.size() > 1) {
			addValidationEntry(Level.ERROR, NodeType.GROUP_NODE, null, 
					"Only one group of type " + nxClass.getSimpleName() + " maybe specified. Found " + childrenOfClass.size() + ": " + String.join(", ", childrenOfClass.keySet()));
			return false;
		}
		
		return true;
	}
	
	protected <N extends NXobject> N getFirstGroupOrNull(Map<String, N> groupsOfType) {
		return groupsOfType.isEmpty() ? null : groupsOfType.values().iterator().next();
	}
	
	/**
	 * Validates that the given field value is not <code>null</code>.
	 * @param fieldName name of field
	 * @param dataset the field value, an {@link IDataset}
	 * @return 
	 */
	public boolean validateFieldNotNull(String fieldName, ILazyDataset dataset) {
		return validate(dataset != null, Level.ERROR, NodeType.DATA_NODE, fieldName, "must be set");
	}
	
	/**
	 * Validates that the given attribute node is not <code>null</code>.
	 * @param attributeName name of attribute
	 * @param attribute attribute 
	 * @return 
	 */
	public boolean validateAttributeNotNull(String attributeName, Attribute attribute) {
		return validate(attribute != null, Level.ERROR, NodeType.ATTRIBUTE, attributeName, "must be set");
	}
	
	/**
	 * Validates that an enumeration field has one of the given permitted values.
	 * @param fieldName name of the field
	 * @param dataset the field value, a {@link Dataset}
	 * @param permittedValues the permitted values
	 * @return 
	 */
	public boolean validateFieldEnumeration(String fieldName, ILazyDataset dataset, String... permittedValues) {
		return validateEnumeration(fieldName, NodeType.DATA_NODE, dataset, permittedValues);
	}
	
	/**
	 * Validates that the type of the given field is that given.
	 * @param fieldName field name
	 * @param dataset field value, an {@link IDataset}
	 * @param type expected type
	 * @return 
	 */
	public boolean validateFieldType(final String fieldName, final ILazyDataset dataset, final NexusDataType type) {
		try {
			if (!type.validate(dataset)) {
				addValidationEntry(Level.ERROR, NodeType.DATA_NODE, fieldName,
						"The dataset type is not compatible with the type " + type);
				return false;
			}
		} catch (NexusException e) {
			addValidationEntry(Level.ERROR, NodeType.DATA_NODE, fieldName,
					"Could not validate dataset according to type " + type); 
		}
		
		return true;
	}
	
	/**
	 * Validates that the given field has units consistent with the given unit category.
	 * 
	 * @param fieldName field name
	 * @param dataNode the {@link DataNode} for the field
	 * @param unitCategory expected unit category
	 * @throws Exception if an unexpected exception occurs
	 */
	public boolean validateFieldUnits(final String fieldName, final DataNode dataNode, final NexusUnitCategory unitCategory) {
		final Attribute unitsAttribute = dataNode.getAttribute(ATTRIBUTE_NAME_UNITS);
		if (unitsAttribute == null) {
			if (unitCategory.isRequired()) {
				addValidationEntry(Level.ERROR, NodeType.DATA_NODE, fieldName, MessageFormat.format("No units attributes specified, expected ''{1}''.", fieldName, unitCategory));
				return false;
			} else {
				return true; // units not required
			}
		}
		
		final String unitsStr = unitsAttribute.getFirstElement();
		try {
			final Unit<?> unit = SimpleUnitFormat.getInstance().parse(unitsStr);
			if (!unitCategory.isCompatible(unit)) {
				addValidationEntry(Level.ERROR, NodeType.DATA_NODE, fieldName,
						MessageFormat.format("Units ''{0}'' are not compatible with unit category ''{1}''.", unitsStr, unitCategory));
				return false;
			}
		} catch (ParserException e) {
			addValidationEntry(Level.ERROR, NodeType.DATA_NODE, fieldName, MessageFormat.format("Invalid units ''{0}''.", unitsStr));
			return false;
		}
		
		return true;
	}
	
	/**
	 * Validates that the given field has the expected rank.
	 * @param fieldName field name
	 * @param dataset field value, an {@link IDataset}
	 * @param rank expected rank
	 * @return
	 */
	public boolean validateFieldRank(final String fieldName, final ILazyDataset dataset, final int rank) {
		if (dataset.getRank() != rank) {
			addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName, 
					"Incorrect rank, was " +  dataset.getRank() + ", expected " + rank); 
		}
		return false;
	}
	
	/**
	 * Validate the dimensions of the given field.
	 * @param fieldName field name
	 * @param dataset dataset to validate
	 * @param groupName the name of the group
	 * @param dimensions the dimensions, each value must be either an integer, interpreted as the expected size of
	 *    that dimension, or a placeholder string, in which case the size of this dimension will be validated
	 *    against any previous dimension with the same placeholder string
	 */
	public void validateFieldDimensions(final String fieldName, final ILazyDataset dataset, String groupName, Object... dimensions) {
		final int[] shape = dataset.getShape();

		for (int i = 0; i < dimensions.length; i++) {
			if (dimensions[i] instanceof Integer) {
				// the dimension value to validate against in an integer specifying exactly the expected dimension size to check
				if (shape[i] != ((Integer) dimensions[i]).intValue()) {
					addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName, MessageFormat.format(
							"The dimension with index {0} has size {1}, expected {2}", (i + 1), shape[i], dimensions[i]));
				}
			} else if (dimensions[i] instanceof String) {
				// the dimension value to validate against is a string placeholder
				// if the name of the group is specified, then this is defined in the NXDL for the base class for that group type
				// otherwise the placeholder is global across the whole application
				
				// we need to check that all dimensions (across the group or application depending on whether there is a group name)
				// have the same size. To do this, if this is the first time we've seen this placeholder we store the size of the
				// current dimension. On subsequent encounters, we check that the current dimension has the same size as this
				// stored value
				final String dimensionPlaceholder = (String) dimensions[i];
				Integer expectedSize = getDimensionPlaceholderValue(dimensionPlaceholder, groupName != null, shape[i]);
				if (expectedSize != null && shape[i] != expectedSize.intValue()) {
					if (groupName != null) {
						addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName, MessageFormat.format(
								"The dimension with index {0} has size {1}, expected {2} (according to symbol ''{3}'' within group {4}",
								(i + 1), shape[i], expectedSize, dimensions[i], groupName));
					} else {
						addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName, MessageFormat.format(
								"The dimension with index {0} has size {1}, expected {2} (according to symbol ''{3}'')",
								(i + 1), shape[i], expectedSize, dimensions[i]));
					}
				}
			} else {
				// this method should never be called if with dimensions that are not an Integer or String
				throw new IllegalStateException("Dimension size value must be an Integer or String, was: " + dimensions[i].getClass().getName());
			}
		}
	}
	
	/**
	 * Validates that the type of the given attribute is that given.
	 * @param attributeName field name
	 * @param dataset field value, an {@link IDataset}
	 * @param type expected type
	 */
	public void validateAttributeType(final String attributeName, final Attribute attribute, final NexusDataType type) {
		try {
			if (!type.validate(attribute.getValue())) {
				addValidationEntry(Level.ERROR, NodeType.ATTRIBUTE, attributeName,
						"The dataset type is not compatible with the type " + type); 
			}
		} catch (NexusException e) {
			addValidationEntry(Level.ERROR, NodeType.ATTRIBUTE, attributeName,
					"Could not validate dataset according to type " + type); 
		}
	}

	/**
	 * Validates that an enumeration attribute has one of the given permitted values.
	 * @param attributeName name of the attribute
	 * @param attribute the attribute
	 * @param permittedValues the permitted values
	 */
	public void validateAttributeEnumeration(String attributeName, Attribute attribute, String... permittedValues) {
		validateEnumeration(attributeName, NodeType.ATTRIBUTE, attribute.getValue(), permittedValues);
	}
	
	public NexusPathSegment toNexusPathSegment(String segment) {
		if (segment.contains(NexusFile.NXCLASS_SEPARATOR)) {
			// segment specifies both name and nexus class
			final String[] parts = segment.split(NexusFile.NXCLASS_SEPARATOR, 2); // max segments is 2
			return new NexusPathSegment(parts[0], NexusBaseClass.getBaseClassForName(parts[1]));
		}
		if (segment.startsWith("NX") && NexusBaseClass.getBaseClassForName(segment) != null) {
			// segment nexus class only
			return new NexusPathSegment(null, NexusBaseClass.getBaseClassForName(segment));
		}
		// segment specifies name only
		return new NexusPathSegment(segment, null);
	}
	
	public void validateDataNodeLink(String fieldName, DataNode dataNode, String targetPath) {
		final DataNode targetNode = getTargetNode(fieldName, targetPath);
		if (targetNode == null) {
			addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName, "No data node at the expected target path: " + targetPath);
		} else {
			validate(targetNode == dataNode, Level.WARNING, NodeType.DATA_NODE, fieldName, "Not a link to the data node at the target path: " + targetPath);
		}
	}
	
	private NexusPathSegment[] parseTargetPath(String targetPath) {
		if (!targetPath.startsWith(Node.SEPARATOR)) {
			throw new IllegalArgumentException("Target path must be absolute: " + targetPath);
		}
		
		final String[] segments = targetPath.split(Node.SEPARATOR);
		// note: since path starts with separator, first element is always empty
		return Arrays.stream(segments, 1, segments.length).
			map(this::toNexusPathSegment).
			toArray(NexusPathSegment[]::new);
	}

	private DataNode getTargetNode(String fieldName, String targetPath) {
		final NexusPathSegment[] parsedTargetPath = parseTargetPath(targetPath);
		
		// The first segment is the entry we're validatings
		final NexusPathSegment firstSegment = parsedTargetPath[0];
		final NexusBaseClass firstSegmentClass = firstSegment.getNexusBaseClass();
		if (!(firstSegmentClass == NexusBaseClass.NX_ENTRY || firstSegmentClass == NexusBaseClass.NX_SUBENTRY
				|| "entry".equals(firstSegment.getName()))) {
			throw new IllegalArgumentException("First segment of target expected to be 'entry' or 'NXentry': " + targetPath);
		}
		
		// iterate through all nodes 
		NXobject currentGroup = entry;
		for (NexusPathSegment segment : Arrays.copyOfRange(parsedTargetPath, 1, parsedTargetPath.length - 1)) {
			if (segment.getName() != null) {
				// segment specifies a group name, get group and check nexus class if specified
				final NXobject groupNode = (NXobject) currentGroup.getGroupNode(segment.getName());
				if (groupNode == null) {
					addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName, 
							MessageFormat.format("No group found with name ''{0}'' with target path ''{1}''.", segment.getName(), targetPath));
					return null;
				} else if (segment.getNexusBaseClass() != null && segment.getNexusBaseClass() != groupNode.getNexusBaseClass()) {
					addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName,
							MessageFormat.format("Group ''{0}'' in target path ''{1}'' has unexpected nexus class ''{2}''.",
							segment.getName(), targetPath, segment.getNexusBaseClass().getJavaClass().getSimpleName()));
					return null;
				}
			}
			
			// if name is not specified, nexus class must be. There should be exactly one child group of this nexus class within the parent group
			final Class<? extends NXobject> nexusClass = segment.getNexusBaseClass().getJavaClass();
			final Map<String, ? extends NXobject> childGroups = currentGroup.getChildren(nexusClass);
			if (childGroups.isEmpty()) {
				addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName,
						MessageFormat.format("No such target group of type ''{0}'' in target path ''{1}''", nexusClass.getSimpleName(), targetPath));
				return null;
			} else if (childGroups.size() > 1) {
				addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName,
						MessageFormat.format("Ambiguous target path ''{0}'', multiple ''{1}'' groups found.", targetPath, nexusClass.getSimpleName()));
				return null;
			}
			currentGroup = childGroups.values().iterator().next();
		}
		
		final NexusPathSegment lastSegment = parsedTargetPath[parsedTargetPath.length - 1];
		final DataNode dataNode = currentGroup.getDataNode(lastSegment.getName());
		if (dataNode == null) {
			addValidationEntry(Level.WARNING, NodeType.DATA_NODE, fieldName,
					MessageFormat.format("No DataNode found with name ''{0}'' for with target path ''{1}''", lastSegment.getName(), targetPath));
			return null;
		}
		
		return dataNode;
	}
	
	public void validateTransformations(final Map<String, NXtransformations> transformations, ILazyDataset dependsOn) {
		try {
			final IDataset dependsOnDataset = dependsOn.getSlice();
			final String dependsOnStr =
					dependsOnDataset.getRank() == 0 ? dependsOnDataset.getString() : dependsOnDataset.getString(0);
			validateTransformations(transformations, dependsOnStr);
		} catch (DatasetException e) {
			addValidationEntry(Level.ERROR, NodeType.DATA_NODE, "depends_on",
					"Could not load dataset"); 
		}
		
	}

	
	/**
	 * Validate the given transformations. Transformations have an order, whereby the initial dependsOnStr
	 * identifies the first transformation, and thereafter each transformation is identified by the
	 * value of the <code>depends_on</code> attribute of the previous transformation. The 
	 * final transformation is identified by having <code>"."</code> as the value of its depends_on attribute. 
	 * @param transformations transformations
	 * @param dependsOnStr the name of the first transformation
	 */
	public void validateTransformations(final Map<String, NXtransformations> transformations, String dependsOnStr) {
		final Set<String> encounteredTransformationNames = new HashSet<>();
		do {
			// get the tranformation with the given name
			final NXtransformations transformation = transformations.get(dependsOnStr);
			
			// check that the transformation exists
			if (transformation == null) {
				addValidationEntry(Level.ERROR, NodeType.GROUP_NODE, dependsOnStr, "No such NXtransformation group: " + dependsOnStr);
				return;
			}
			
			// check we haven't already encountered this transformation, if so the
			// transformations have a circular dependency
			if (encounteredTransformationNames.contains(dependsOnStr)) {
				addValidationEntry(Level.ERROR, NodeType.GROUP_NODE, dependsOnStr,
						"Circular dependency detected in transformations, transformation '" + dependsOnStr + "' encountered for second time.");
				return;
			}
			
			encounteredTransformationNames.add(dependsOnStr);
			final Attribute dependsOnAttr = transformation.getAttribute("depends_on");
			dependsOnStr = (dependsOnAttr == null ? null : dependsOnAttr.getFirstElement());
		} while (dependsOnStr != null && !dependsOnStr.equals(".")); // "." marks the final transformation
	}
	
	/**
	 * Clears the map of values of dimension placeholders, as these are local only to the current group.
	 */
	public void clearLocalGroupDimensionPlaceholderValues() {
		localGroupDimensionPlaceholderValues = new HashMap<>();
	}

	/**
	 * Validate that the value of the given dataset is one of the permitted values for an enumeration.
	 * @param nodeName node name
	 * @param nodeType type of node, can be field or attribute
	 * @param lazyDataset dataset to validate
	 * @param permittedValues permitted values
	 * @return
	 */
	private boolean validateEnumeration(String nodeName, NodeType nodeType, ILazyDataset lazyDataset, String... permittedValues) {
		// note: this method assumes that the enumeration values are always strings
		if (lazyDataset.getRank() > 1) { // scalar datasets can also be written as one-dimensional datasets of size one 
			addValidationEntry(Level.ERROR, nodeType, nodeName, "the dataset for an enumeration must have rank 0 or 1");
			return false;
		}
		
		// the size of scalar fields can be 0 or 1 (i.e. we treat one dimensional datasets of size 1 as scalar)
		if (lazyDataset.getSize() > 1) {
			addValidationEntry(Level.ERROR, nodeType, nodeName, "the dataset for an enumeration must have a size of 1");
			return false;
		}
		
		final IDataset dataset;
		try {
			dataset = lazyDataset.getSlice();
		} catch (DatasetException e) {
			addValidationEntry(Level.ERROR, nodeType, nodeName, "the dataset could not be read");
			return false;
		}
		
		final String value = dataset.getRank() == 0 ? dataset.getString() : dataset.getString(0);
		if (value == null) {
			addValidationEntry(Level.ERROR, nodeType, nodeName, "The value for the enumeration cannot be null");
			return false;
		}
		
		final boolean valuePermitted = Arrays.stream(permittedValues).anyMatch(enumVal -> enumVal.equals(value));
		if (!valuePermitted) {
			addValidationEntry(Level.ERROR, nodeType, nodeName, MessageFormat.format("The value ''{0}'' is not in the enumeration of permitted values: {1}",
					value, String.join(", ", permittedValues)));
			return false;
		}
		
		return true;
	}

	/**
	 * A helper method to get the actual dimension size for the given placeholder string, if it exists.
	 * If this is the first occurrence of this placeholder, 
	 * @param placeholder
	 * @param local
	 * @param actualDimensionSize
	 * @return the dimension placeholder value
	 */
	private int getDimensionPlaceholderValue(String placeholder, boolean local, int actualDimensionSize) {
		if (local) {
			return localGroupDimensionPlaceholderValues.computeIfAbsent(placeholder, str -> actualDimensionSize);
		}
		
		return globalDimensionPlaceholderValues.computeIfAbsent(placeholder, str -> actualDimensionSize);
	}
	
}
